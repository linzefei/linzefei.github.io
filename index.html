<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>3D Text Animation</title>
	<style>
		canvas {
			display: block;
			margin: 0 auto;
			background-color: #000;
		}
	</style>
</head>

<body>
	<canvas id="scene"></canvas>
	<script>
		const canvas = document.getElementById('scene');
		const ctx = canvas.getContext('2d');
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;

		class Text3D {
			constructor(text, x, y, z, size, color) {
				this.text = text;
				this.x = x;
				this.y = y;
				this.z = z;
				this.size = size;
				this.color = color;
				this.vx = Math.random() * 4 - 2;
				this.vy = Math.random() * 4 - 2;
			}

			update() {
				this.x += this.vx;
				this.y += this.vy;
				if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
				if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
			}

			draw() {
				ctx.save();
				ctx.translate(this.x, this.y);
				ctx.scale(this.z / 100, this.z / 100);
				ctx.fillStyle = this.color;
				ctx.font = `${this.size * (100 / this.z)}px Arial`;
				ctx.fillText(this.text, -ctx.measureText(this.text).width / 2, this.size / 2);
				ctx.restore();
			}


			// 检查两个Text3D对象是否碰撞
			collidesWith(other) {
				// 计算两个文本的边界盒
				const thisBox = {
					x: this.x - this.size / 2,
					y: this.y - this.size / 2,
					width: this.size,
					height: this.size
				};
				const otherBox = {
					x: other.x - other.size / 2,
					y: other.y - other.size / 2,
					width: other.size,
					height: other.size
				};

				// 检查边界盒是否相交
				return !(thisBox.x + thisBox.width < otherBox.x ||
					thisBox.x > otherBox.x + otherBox.width ||
					thisBox.y + thisBox.height < otherBox.y ||
					thisBox.y > otherBox.y + otherBox.height);
			}
		}


		const texts = [
			new Text3D('Hello', 100, 100, 50, 30, 'red'),
			new Text3D('Hello', 100, 100, 50, 30, 'red'),
			new Text3D('Hello', 100, 100, 50, 30, 'red'),
			new Text3D('Hello', 100, 100, 50, 30, 'red'),
			new Text3D('Hello', 100, 100, 50, 30, 'red'),
			new Text3D('Hello', 100, 100, 50, 30, 'red'),
			new Text3D('Hello', 100, 100, 50, 30, 'red'),
			new Text3D('Hello', 100, 100, 50, 30, 'red'),
			new Text3D('World', 300, 200, 70, 30, 'green')
		];

		// 在动画循环中检查碰撞
		function animate() {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			texts.forEach((text, index) => {
				text.update();
				// 检查与其他文本的碰撞
				for (let i = index + 1; i < texts.length; i++) {
					if (text.collidesWith(texts[i])) {
						// 处理碰撞，例如改变颜色、方向或速度
						text.color = 'blue';
						texts[i].color = 'blue';
					}
				}
				text.draw();
			});
			requestAnimationFrame(animate);
		}

		animate();
	</script>
</body>

</html>